A Tour of Go

The Go Authors
http://golang.org

* Hello, 안녕

[[http://golang.org][Go 프로그래밍 언어]] 투어에 오신 것을 환영합니다.

이 투어는 3개의 섹션으로 되어 있고, 각 섹션의 마지막 부분에는 좀더 완벽한 이해를 돕기 위해 연습문제가 준비되어 있습니다.

지금 Run 버튼을 클릭해보거나 키보드에서 Shift-Enter 키를 눌러보세요. 옆의 Go 소스가 컴파일되고 실행될 겁니다. 실행 결과는 코드 밑에 표시됩니다.

이 투어에 있는 많은 예제 프로그램들은 Go가 다른 언어들과 어떤 차이점이 있는지 보여줄 것이고, 여러분이 Go를 배우는데 출발점이 될 것입니다.

소스를 수정하고 다시 한번 실행해보세요.

이제 다음으로 넘어갈 준비가 되었으면, Next 버튼을 클릭하거나 PageDown 키를 누르세요.

.play prog/hello.go

* Go local

이 투어는 다른 나라 언어로도 이용할 수 있습니다:

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese — Português do Brasil]]
- [[http://go-tour-he.appspot.com/][Hebrew — עִבְרִית]]
- [[http://go-tour-zh.appspot.com/][Chinese — 普通话]]
- [[http://go-tour-jp.appspot.com/][Japanese — 日本語]]

계속 하시려면 Next 버튼을 클릭하거나 PageDown 키를 누르세요.

* 패키지(Packages)

모든 Go 프로그램은 패키지로 구성됩니다.

프로그램은 `main` 패키지에서 시작합니다.

이 프로그램은 `"fmt"` 와 `"math"` 경로에 있는 패키지를 사용합니다.

패키지 이름은 경로의 마지막 이름을 사용하는 것이 규칙입니다. 예를 들어 `"path/filepath"` 를 사용한다면 패키지명은 `filepath` 입니다.

.play prog/packages.go

* 임포트 (Imports)

이 코드에서는 여러개의 `"package"` 를 소괄호로 감싸서 import를 표현합니다. 아래와 같이 import 문장을 여러번 사용할 수 도 있습니다.

	import "fmt"
	import "math"

.play prog/imports.go

* 익스포트 (Exported names)

패키지를 Import 하면 패키지에서 export 한 내용을 사용(참조)할 수 있습니다.

Go에서는 Export하기 위해서 첫 글자가 대문자로 시작해야 합니다.

예를 들어 `Foo` 와 `FOO` 는 외부에서 참조할 수 있지만 `foo` 는 참조 할 수 없습니다.

예제를 실행해보세요. 애러가 발생한다면 `math.pi` 를 `math.Pi` 로 변경 해보세요.

.play prog/exported-names.go

* 함수

함수는 매개변수(인자)를 취할 수 있습니다.

예를 들어 `add` 라는 함수는 두개의 `int` 타입 매개변수를 받습니다.

C, C++, Java 언어와 다르게 매개변수의 타입은 변수명 _뒤에_ 명시합니다.

(타입을 왜 변수명 뒤에 명시하는지에 대한 자세한 내용은 [[http://golang.org/doc/articles/gos_declaration_syntax.html][Go's declaration syntax]]를 참고하시기 바랍니다. 간단히 설명하면 코드를 왼쪽에서 오른쪽으로 읽을 때 자연스럽게 읽기 위해서 입니다.)

.play prog/functions.go

* 함수 (2)

두 개 이상의 매개변수가 같은 타입(type)일 때, 같은 타입을 취하는 마지막 매개변수에만 타입을 명시하고 나머지는 생략할 수 있습니다.

예를 들어

	x int, y int

과 같은 문장은 아래와 같이 표현할 수 있습니다.

	x, y int

.play prog/functions-continued.go

* 여러 개의 결과 (Multiple results)

하나의 함수는 여러 개의 결과를 반환할 수 있습니다.

예제 코드에서의 함수는 두개의 문자열을 반환합니다.

.play prog/multiple-results.go

* 이름이 정해진 결과 (Named results)

함수는 매개변수를 취합니다. Go에서 함수는 여러 개의 결과를 반환할 수 있습니다. 반환 값에 이름을 부여하면 변수처럼 사용할 수도 있습니다.

결과에 이름을 붙히면, 반환 값을 지정하지 않은 `return` 문장으로 결과의 현재 값을 알아서 반환합니다.

.play prog/named-results.go

* 변수 (Variables)

변수를 선언을 위해 `var` 을 사용합니다.

함수의 매개변수처럼 타입은 문장 끝에 명시합니다.

.play prog/variables.go

* 변수의 초기화

변수 선언과 함께 변수 각각을 초기화를 할 수 있습니다.

초기화를 하는 경우 타입(type)을 생략할 수 있습니다. 변수는 초기화 하고자 하는 값에 따라 타입이 결정됩니다.

.play prog/variables-with-initializers.go

* 변수의 짧은 선언

함수 내에서 `:=` 을 사용하면 `var` 과 명시적인 타입(e.g. int, bool) 을 생략할 수 있습니다.

(그러나 함수 밖에서는 `:=` 선언을 사용할 수 없습니다.)

.play prog/short-variable-declarations.go

* 상수 (Constants)

상수는 `const` 키워드와 함께 변수처럼 선언합니다.

상수는 문자(character), 문자열(string), 부울(boolean) 등(values)일 수 있습니다.

.play prog/constants.go

* 숫자형 상수 (Numeric Constants)

숫자형 상수는 _정밀한 값(values)_ 을 표현할 수 있습니다.

타입을 지정하지 않은 상수는 문맥(context)에 따라 타입을 가지게 됩니다.

코드를 통해 `needInt(Big)` 는 어떤 결과를 출력할지 실험해보세요.

.play prog/numeric-constants.go

* For (반복문 for)

Go 언어는 반복문이 `for` 밖에 없습니다.

기본적인 `for` 반복문은 C와 Java 언어와 거의 유사합니다. 다른점은 소괄호 ( )가 필요하지 않다는 것입니다.

하지만 실행문을 위한 중괄호 { } 는 필요합니다.

.play prog/for.go

* For (2)

C와 Java에서 처럼 조건문만 표현할 수도 있습니다.

.play prog/for-continued.go

* Go에서 "While" 사용하기

for(2)에서의 예제에서 처럼 조건문만 표시하면 C에서 `while` 을 사용하듯 Go에서 `for` 를 사용할 수 있습니다.

.play prog/for-is-gos-while.go

* 무한 루프

for에서 조건문을 생략하면 무한루프를 표현할 수 있습니다.

.play prog/forever.go

* 조건문 (If)

`if` 문은 C와 Java와 비슷합니다. 조건 표현을 을 위해 `(`)` 는 사용하지 않습니다. 하지만 실행문을 위한 `{`}` 는 반드시 작성해야합니다.

(For문과 비슷하죠?)

.play prog/if.go

* If와 짧은 실행문 사용하기

`for` 처럼 `if` 에서도 조건문 앞에 짧은 문장을 실행할 수 있습니다.

짧은 실행문을 통해 선언된 변수는 `if` _안의 범위(scope)_ 에서 만 사용할 수 있습니다.

(코드의 `pow` 함수에서 `return` 전에 `v` 를 사용해보세요.)

.play prog/if-with-a-short-statement.go

* If와 else

`if` 에서 짧은 실행문을 통해 선언된 변수는 `else` 안에서도 사용 가능합니다.

.play prog/if-and-else.go

* 기본 타입

Go의 기본 타입은 아래와 같습니다.

	bool
	
	string
	
	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr
	
	byte // uint8의 별칭
	
	rune // int32의 별칭
	     // 유니코드 값을 표
	
	float32 float64
	
	complex64 complex128

.play prog/basic-types.go

* 구조체 (Structs)

`struct` 는 필드의 조합입니다.

(그리고 `type` 선언으로 struct의 이름을 지정할 수 있습니다.)

.play prog/structs.go

* 구조체 필드

구조체 필드는 dot(.) 으로 접근합니다.

.play prog/struct-fields.go

* 포인터 (Pointers)

Go에는 포인터가 있지만 포인터 연산은 불가능합니다.

구조체 포인터로 구조체 필드에 접근할 수 있습니다.

(The indirection through the pointer is transparent.)

.play prog/pointers.go

* 구조체 리터럴 (Struct Literals)

구조체 리터럴은 필드의 값을 나열해서 구조체 값을 새롭게 할당하는 방법입니다.

원하는 필드를 `{Name: value}` 문법을 통해 할당할 수 있습니다. (필드의 순서는 상관 없습니다.)

특수 기호 `&` 는 구조체 리터럴의 포인터를 생성합니다.

.play prog/struct-literals.go

* new 함수

`new(T)` 는 모든 필드가 0(zero value)이 할당된 `T` 의 포인터를 반환합니다.

	var t *T = new(T)

또는

	t := new(T)

.play prog/the-new-function.go

* 맵 (Maps)

맵은 값에 키를 지정합니다.

맵은 반드시 사용하기 전에 `make` 를 명시해야합니다. (주의: `new` 가 아닙니다)

`make`를 수행하지 않은 `nil` 에는 값을 할당할 수 없습니다.

.play prog/maps.go

* 맵 리터럴 (Map literals)

맵 리터럴은 구조체 리터럴과 비슷하지만 `key` 를 반드시 지정해야 합니다.

.play prog/map-literals.go

* 맵 리터럴 (2)

만약 가장 상위의 타입이 타입명이라면 리터럴에서 타입명을 생략해도 됩니다.

	"Bell Labs": {40.68433, -74.39967}

또는

	"Bell Labs": Vertex{40.68433, -74.39967}

는 같은 표현입니다.

.play prog/map-literals-continued.go

* 맵 다루기 (Mutating Maps)

맵 `m` 의 요소를 삽입하거나 수정하기:

	m[key] = elem

요소 값 가져오기:

	elem = m[key]

요소 지우기:

	delete(m, key)

키의 존재 여부 확인하기:

	elem, ok = m[key]

위의 `ok` 의 값은 `m` 에 `key` 가 존재한다면 `true` 존재하지 않으면 `false`, `elem` 은 타입에 따라 0(zero value) 가 됩니다.

이처럼 `map` 을 읽을 때, 존재하지 않는 `key` 의 반환 값은 타입에 맞는 _zero value_ 입니다.

.play prog/mutating-maps.go

* 슬라이스 (Slices)

슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다.

`[]T` 는 타입 `T` 를 가지는 요소의 슬라이스(slice) 입니다.

.play prog/slices.go

* 슬라이스 자르기 (Slicing slices)

슬라이스는 재분할 할 수도 있고, 같은 배열을 가리키는(point) 새로운 슬라이스를 만들 수 도 있습니다.

예제로 살펴보면

	s[lo:hi]

위의 표현은 `lo` 에서 `hi-1` 의 요소(element)를 포함하는 슬라이스입니다. 따라서

	s[lo:lo]

는 빈(empty) 슬라이스 이고

	s[lo:lo+1]

는 하나의 요소를 가집니다.

.play prog/slicing-slices.go

* 슬라이스 만들기

슬라이스는 `make` 함수로 만들 수 있습니다. 이렇게 생성된 슬라이스는 0을 할당한 배열을 생성하고, 그것을 참조(refer)합니다.

	a := make([]int, 5)  // len(a)=5

`make` 함수의 세번째 매개변수로 최대(capacity)를 제한할 수 있습니다.

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/making-slices.go

* Nil 슬라이스

슬라이스의 zero value는 `nil` 입니다.

nil 슬라이스는 길이와 최대 크기가 0입니다.

(슬라이스에 대해 더 알고 싶다면 다음 글을 읽어보세요. [[http://golang.org/doc/articles/slices_usage_and_internals.html][Slices: usage and internals]])

.play prog/nil-slices.go

* 함수 값 (Function values)

함수도 변수입니다.

.play prog/function-values.go

* 함수 클로져 (Function closures)

그리고 함수는 클로져(full closures) 입니다.

코드에서 `adder` 함수는 클로져(closure)를 반환합니다.

각각의 클로져는 자신만의 `sum` 변수를 가집니다.

.play prog/function-closures.go

* 레인지 (Range, 범위)

`for` 반복문에서 `range` 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.

.play prog/range.go

* 레인지 (2)

`_` 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다.

만약 인덱스만 필요하다면 “ `, value` ” 를 다 지우면 됩니다.

	for i, value := range pow {
        pow[i] = 1 << uint(i)
    }

에서

	for i := range pow {
        pow[i] = 1 << uint(i)
    }

처럼 사용할 수 있습니다.

.play prog/range-continued.go

* 스위치 (Switch)

다른 일반적인 언어를 아는 분이라면 `switch` 에 대해서 잘 알 것입니다.

다른 언어와 다른점은 케이스 Body 실행을 마치면 알아서 break를 한다는 점입니다.

( `fallthrough` 로 끝나는 케이스는 스스로 break를 하지 않습니다 )

.play prog/switch.go

* 스위치 평가 순서

스위치의 각 케이스는 위에서 아래로 평가합니다. 만약 케이스가 성공하면 평가를 마칩니다.

(예를 들어

	switch i {
	case 0:
	case f():
	}

에서 `i==0` 이라면 `f` 는 실행되지 않습니다)

.play prog/switch-evaluation-order.go

* 조건을 생략한 스위치

스위치에서 조건을 생략하면 " `switch` `true` " 와 같습니다.

만약 긴 if-then-else 를 작성해야 한다면, 이 구조를 사용하면 코드를 깔끔하게 정리할 수 있습니다.

.play prog/switch-with-no-condition.go

* Exercise: Loops and Functions

As a simple way to play with functions and loops, implement the square root function using Newton's method.

In this case, Newton's method is to approximate `Sqrt(x)` by picking a starting point _z_ and then repeating:

To begin with, just repeat that calculation 10 times and see how close you get to the answer for various values (1, 2, 3, ...).

Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small delta). See if that's more or fewer iterations. How close are you to the [[http://golang.org/pkg/math/#Sqrt][math.Sqrt]]?

Hint: to declare and initialize a floating point value, give it floating point syntax or use a conversion:

	z := float64(1)
	z := 1.0

.play prog/exercise-loops-and-functions.go

* Exercise: Maps

Implement `WordCount`.  It should return a map of the counts of each “word” in the string `s`. The `wc.Test` function runs a test suite against the provided function and prints success or failure.

You might find [[http://golang.org/pkg/strings/#Fields][strings.Fields]] helpful.

.play prog/exercise-maps.go

* Exercise: Slices

Implement `Pic`. It should return a slice of length `dy`, each element of which is a slice of `dx` 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include `x^y`, `(x+y)/2`, and `x*y`.

(You need to use a loop to allocate each `[]uint8` inside the `[][]uint8`.)

(Use `uint8(intValue)` to convert between types.)

.play prog/exercise-slices.go

* Exercise: Fibonacci closure

Let's have some fun with functions.

Implement a `fibonacci` function that returns a function (a closure) that returns successive fibonacci numbers.

.play prog/exercise-fibonacci-closure.go

* Advanced Exercise: Complex cube roots

Let's explore Go's built-in support for complex numbers via the `complex64` and `complex128` types. For cube roots, Newton's method amounts to repeating:

Find the cube root of 2, just to make sure the algorithm works. There is a [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] function in the `math/cmplx` package.

.play prog/advanced-exercise-complex-cube-roots.go

* Methods and Interfaces

* Methods

Go does not have classes. However, you can define methods on struct types.

The _method_receiver_ appears in its own argument list between the `func` keyword and the method name.

.play prog/methods.go

* Methods continued

In fact, you can define a method on _any_ type you define in your package, not just structs.

You cannot define a method on a type from another package, or on a basic type.

.play prog/methods-continued.go

* Methods with pointer receivers

Methods can be associated with a named type or a pointer to a named type.

We just saw two `Abs` methods. One on the `*Vertex` pointer type and the other on the `MyFloat` value type.

There are two reasons to use a pointer receiver. First, to avoid copying the value on each method call (more efficient if the value type is a large struct). Second, so that the method can modify the value that its receiver points to.

Try changing the declarations of the `Abs` and `Scale` methods to use `Vertex` as the receiver, instead of `*Vertex`.

The `Scale` method has no effect when `v` is a `Vertex`. `Scale` mutates `v`. When `v` is a value (non-pointer) type, the method sees a copy of the `Vertex` and cannot mutate the original value.

`Abs` works either way. It only reads `v`. It doesn't matter whether it is reading the original value (through a pointer) or a copy of that value.

.play prog/methods-with-pointer-receivers.go

* Interfaces

An interface type is defined by a set of methods.

A value of interface type can hold any value that implements those methods.

.play prog/interfaces.go

* Interfaces are satisfied implicitly

A type implements an interface by implementing the methods.

_There_is_no_explicit_declaration_of_intent._

Implicit interfaces decouple implementation packages from the packages that define the interfaces: neither depends on the other.

It also encourages the definition of precise interfaces, because you don't have to find every implementation and tag it with the new interface name.

[[http://golang.org/pkg/io/][Package io]] defines `Reader` and `Writer`; you don't have to.

.play prog/interfaces-are-satisfied-implicitly.go

* Errors

An error is anything that can describe itself as an error string. The idea is captured by the predefined, built-in interface type, `error`, with its single method, `Error`, returning a string:

	type error interface {
		Error() string
	}

The `fmt` package's various print routines automatically know to call the method when asked to print an `error`.

.play prog/errors.go

* 웹 서버

[[http://golang.org/pkg/net/http/][http 패키지]]는 `http.Handler` 를 구현한 값을 사용하여 HTTP requests를 제공합니다.:

	package http
	
	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

왼쪽의 코드를 보면 `http.Handler` 를 구현한 `Hello` 타입을 확인할 수 있습니다.

이 코드를 로컬에서 실행하고, [[http://localhost:4000/][http://localhost:4000/]] 에 접속해보세요.


.play prog/web-servers.go

* Images

[[http://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image
	
	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(See [[http://golang.org/pkg/image/#Image][the documentation]] for all the details.)

Also, `color.Color` and `color.Model` are interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`.

.play prog/images.go

* Exercise: Errors

Copy your `Sqrt` function from the earlier exercises and modify it to return an `error` value.

`Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

Create a new type

	type ErrNegativeSqrt float64

and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

*Note:* a call to `fmt.Print(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Print(float64(e))`. Why?

Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play prog/exercise-errors.go

* Exercise: HTTP Handlers

Implement the following types and define ServeHTTP methods on them. Register them to handle specific paths in your web server.

	type String string
	
	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

For example, you should be able to register handlers using:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/exercise-http-handlers.go

* Exercise: Images

Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[http://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play prog/exercise-images.go

* Exercise: Rot13 Reader

A common pattern is an [[http://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

For example, the [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of gzipped data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[http://en.wikipedia.org/wiki/ROT13][ROT13]] substitution cipher to all alphabetical characters.

The `rot13Reader` type is provided for you.  Make it an `io.Reader` by implementing its `Read` method.

.play prog/exercise-rot-reader.go

* Concurrency

* Goroutines

A _goroutine_ is a lightweight thread managed by the Go runtime.

	go f(x, y, z)

starts a new goroutine running

	f(x, y, z)

The evaluation of `f`, `x`, `y`, and `z` happens in the current goroutine and the execution of `f` happens in the new goroutine.

Goroutines run in the same address space, so access to shared memory must be synchronized. The `[[http://golang.org/pkg/sync/][sync]]` package provides useful primitives, although you won't need them much in Go as there are other primitives. (See the next slide.)

.play prog/goroutines.go

* Channels

Channels are a typed conduit through which you can send and receive values with the channel operator, `<-`.

	ch <- v    // Send v to channel ch.
	v := <-ch  // Receive from ch, and
	           // assign value to v.

(The data flows in the direction of the arrow.)

Like maps and slices, channels must be created before use:

	ch := make(chan int)

By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.

.play prog/channels.go

* Buffered Channels

Channels can be _buffered_.  Provide the buffer length as the second argument to `make` to initialize a buffered channel:

	ch := make(chan int, 100)

Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.

Modify the example to overfill the buffer and see what happens.

.play prog/buffered-channels.go

* Range and Close

A sender can `close` a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after

	v, ok := <-ch

`ok` is `false` if there are no more values to receive and the channel is closed.

The loop `for`i`:=`range`c` receives values from the channel repeatedly until it is closed.

*Note:* Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.

*Another*note*: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a `range` loop.

.play prog/range-and-close.go

* Select

The `select` statement lets a goroutine wait on multiple communication operations.

A `select` blocks until one of its cases can run, then it executes that case.  It chooses one at random if multiple are ready.

.play prog/select.go

* Default Selection

The `default` case in a `select` is run if no other case is ready.

Use a `default` case to try a send or receive without blocking:

	select {
	case i := <-c:
		// use i
	default:
		// receiving from c would block
	}

.play prog/default-selection.go

* Exercise: Equivalent Binary Trees

There can be many different binary trees with the same sequence of values stored at the leaves. For example, here are two binary trees storing the sequence 1, 1, 2, 3, 5, 8, 13.

A function to check whether two binary trees store the same sequence is quite complex in most languages. We'll use Go's concurrency and channels to write a simple solution.

This example uses the `tree` package, which defines the type:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

* Exercise: Equivalent Binary Trees

*1.* Implement the `Walk` function.

*2.* Test the `Walk` function.

The function `tree.New(k)` constructs a randomly-structured binary tree holding the values `k`, `2k`, `3k`, ..., `10k`.

Create a new channel `ch` and kick off the walker:

	go Walk(tree.New(1), ch)

Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.

*3.* Implement the `Same` function using `Walk` to determine whether `t1` and `t2` store the same values.

*4.* Test the `Same` function.

`Same(tree.New(1),`tree.New(1))` should return true, and `Same(tree.New(1),`tree.New(2))` should return false.

.play prog/exercise-equivalent-binary-trees.go

* 연습: 웹 크롤러

이 연습에서는 고의 동시성 기능을 사용해 웹 크롤러를 병렬화 해 볼 것입니다.

`Crawl` 함수를 고쳐서, 같은 URL을 두번 가져오는 중복을 피하면서 URL들을 병렬로 패치하게 고쳐보세요.

.play prog/exercise-web-crawler.go

* 더 살펴볼 곳 들...

우선 [[http://golang.org/doc/][Go 문서]] 사이트에서 시작하는 것이 좋습니다. 여기에서 레퍼런스, 튜토리얼, 비디오 등의 자료를 볼 수 있습니다.

고 코드를 구성하기와 고로 작업하는 방법을 배우려면, [[http://www.youtube.com/watch?v=XCsL89YtqCs][이 스크린캐스트]]를 보거나, [[http://golang.org/doc/code.html][고 코드 작성 방법]]를 읽어 보세요.

표준 라이브러리에 대한 도움이 필요하면, [[http://golang.org/pkg/][패키지 레퍼런스]]를 살펴보세요. 고 언어 자체에 대해서는 [[http://golang.org/ref/spec][언어 스펙]]이 도움이 되며, 아마 꽤 쉽게 스펙문서를 읽을 수 있음에 놀라게 될 것입니다.

더 나아가 고의 동시성(concurrency) 모델을 살펴보려면 코드워크, [[http://golang.org/doc/codewalk/sharemem/][통신으로 메모리 공유하기]]를 보세요.

코드워크, [[http://golang.org/doc/codewalk/functions/][First Class Functions in Go]]에서는 고의 함수 타입에 관련된 흥미로운 관점을 제공합니다.

공식 블로그, [[http://blog.golang.org/][Go ]]에는 유익한 기사들이 많이 있습니다.

공식 사이트 [[http://golang.org][golang.org]]를 방문해 더 살펴보세요.

